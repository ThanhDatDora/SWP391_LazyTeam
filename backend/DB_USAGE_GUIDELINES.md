DB Usage Guidelines
===================

Purpose
-------
Provide a short, practical set of guidelines for working with Microsoft SQL Server from Node in this repository. The runtime uses a shared connection pool and transactions must be bound to that pool. Follow these rules to avoid connection/transaction errors and keep scripts consistent.

Core rules
----------
- Use the shared pool from `backend/config/database.js`.
  - Import dynamically from CommonJS maintenance scripts: `const db = await import(path.join(__dirname, 'config', 'database.js'))` and `const pool = await db.getPool()`.
  - In ESM runtime code, import normally: `import { getPool } from './config/database.js'; const pool = await getPool();`

- For queries use a request from the pool:

  - `const result = await pool.request().input('id', sql.Int, id).query('SELECT ... WHERE id = @id')`

- For transactions always bind to the pool instance:

  - `const transaction = new sql.Transaction(pool); await transaction.begin(); const trRequest = transaction.request(); ... await transaction.commit()`

- Close the pool at the end of one-off maintenance scripts (call `await pool.close()` in finally). Do not close the pool from runtime server code — the server should keep the shared pool open for its lifetime.

Do/Don't
--------
- DO use parameterized queries via `.input()` to avoid SQL injection.
- DO compute DB timestamps or elapsed times on the DB side (DATEDIFF) when values are generated by the database to avoid timezone skew.
- DO log full stack traces server-side but return minimal error messages to clients.

- DON'T use the global `sql.query(...)` or `sql.connect(config)` in runtime controllers — this risks creating queries or transactions without a bound connection and leads to "No connection is specified for that request." errors.
- DON'T close the shared pool from server request handlers. Only maintenance scripts should call `pool.close()` when they are a short-lived process.

Examples
--------

Runtime (ESM controller):

```js
import { getPool, sql } from '../config/database.js';

export async function handler(req, res) {
  const pool = await getPool();
  const result = await pool.request().input('id', sql.Int, req.params.id).query('SELECT * FROM moocs WHERE mooc_id = @id');
  res.json(result.recordset[0]);
}
```

One-off maintenance (CommonJS .cjs):

```js
const path = require('path');
(async () => {
  const db = await import(path.join(__dirname, 'config', 'database.js'));
  const pool = await db.getPool();
  try {
    const r = await pool.request().query('SELECT TOP 1 * FROM exams');
    console.log(r.recordset[0]);
  } finally {
    await pool.close();
  }
})();
```

If you follow these patterns the runtime and scripts will interoperate safely.

Notes
-----
- This file is intentionally concise. If you want, I can expand it into a developer-facing doc with examples per-file and a small checklist for PR reviewers.
